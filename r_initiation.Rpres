Initiation à R
========================================================
author: DREES
date: `r Sys.Date()`
autosize: true

Qu'est ce que R ?
========================================================

### R (https://www.r-project.org/) est un langage de programmation dédié à l'analyse statistique.
### Libre et gratuit, disponible sur toutes les plateformes (Mac OS, Windows, Linux), il s'est largement imposé ces dernières années dans le domaine des sciences humaines et de la datascience.
### R dispose par défaut d'instructions de base permettant de réaliser les opérations les plus courantes.
### De nouvelles fonctionnalités, regroupées en packages, peuvent être facilement ajoutées pour venir enrichir les possibilités du langage.
### Le point fort de R par rapport à des logiciels à interfaces graphiques, est qu'il permet très facilement l'automatisation et la reproductibilité des traitements.

Environnement de travail
========================================================

### Rstudio (https://www.rstudio.com/) est un environnement de travail permettant d'écrire du code R. 
### Il ne s'agit pas d'un environnement clic bouton mais d'une véritable interface de développement (IDE) destiné à écrire du code. 
### Il s'agit en fait d'une couche logiciel permettant d'écrire, d'exécuter et de visualiser les résultats d'un programme écrit dans le langage R. 
### RStudio n'est pas indispensable pour utiliser R. Néanmoins,  il est très pratique et très bien fait.

Répertoire par défaut
========================================================
Le menu Session > Set Working Directory permet de sélectionner le répertoire par défaut contenant vos scripts et éventuels fichiers de données.<br>
Vous pouvez également le modifier via une ligne de code :

```{r message=TRUE, warning=FALSE}
setwd('C:/Users/phileas.condemine/Documents/R_initiation/')
```

Une autre approche, souvent préférable, est l'utilisation des projets.<br>
Le bouton situé en haut à droite de l'environnement RStudio permet de gérer les projets.<br>
Dans un projet l'environnement de travail est automatiquement défini comme le lieu d'emplacement du projet (fichier .Rproj).<br>
Le fichier en lui même est très simple mais peut-être paramétré.
```{r}
print(readLines("R_initiation.Rproj"))
```

Quelques raccourcis dans RStudio
========================================================
<ul>
<li> [ctrl+entrée] pour compiler une ligne, vous pouvez placer le curseur dessus et cliquer sur Run, ou bien utiliser le raccourci clavier .
<li> [TAB] pour utiliser l'autocomplétion d'un nom de fonction, de variable ou de fichier (si des entre guillements "")
<li> [Ctrl + Shift + 1] Pour ouvrir le code en plein écran, refaire le même raccourci pour revenir à l'affichage 4 fenêtres
<li> [Ctrl + Shift + 2] Pour ouvrir la console en plein écran, refaire le même raccourci pour revenir à l'affichage 4 fenêtres
<li> [Ctrl + Alt + i] Pour créer un nouveau chunk de code R dans un fichier .Rmd ou .Rpres
<li> [Alt +  -] Pour créer un signe ` <- `
</ul>


Objets et formats en théorie
========================================================
### Sous R, les éléments de base sont des objets : 
<ul>
<li>vecteurs, 
<li>matrices, 
<li>listes, 
<li>table appelées <b>data.frame</b> ...
</ul>
### Ces objets peuvent contenir des éléments de type 
<ul>
<li>numérique, 
<li>booléen (logical : TRUE, FALSE), 
<li>chaîne de caractère (string), 
<li>facteur (factor, pour les variables qualitatives prenant un nombre déterminé de modalités). 
</ul>
### La différence entre la table de données (data.frame) et la matrice tient notamment dans le fait que la première peut contenir des éléments de types différents. 

Packages
========================================================
```{r,message=FALSE, warning=FALSE,print=FALSE}
sapply(c("ggplot2","plotly","factoextra","webshot","dplyr"),function(x){
  library(x,character.only=T,quietly = T)
  })
```


Nombres - Opérations simples
========================================================

On commence par créer des éléments pour illustrer les opérations de base en R.<br>
Le signe `<-` est très souvent équivalent à `=`<br>
Ils permettent d'assigner un contenu à une variable dont on indique le nom à gauche.
On peut ensuite avoir un aperçu de ces variables dans l'onglet Environment (par défaut en haut à droite).
```{r message=FALSE, warning=FALSE}
element_a <- 2
element_a
element_b <- 3
element_b
element_c <- element_a/2 + 2*element_b # les opérations -, *, /, sqrt pour racine, ^ pour puissance, log, exp, sont également possibles !
element_c
```

Vecteurs - Création et combinaison
========================================================
On peut travailler très naturellement sur des vecteurs<br>
Le vecteur est le format par défaut en R. Un nombre seul ie un scalaire est un vecteur de taille 1.<br>
c() veut dire combine parce que cet opérateur permet de combiner des vecteurs (y compris de taille 1).

```{r message=FALSE, warning=FALSE}
vecteur_a <- c(2,3,5) 
vecteur_a
```

```{r message=FALSE, warning=FALSE}
vecteur_b <- c(-1,0,1)
vecteur_b
```

```{r message=FALSE, warning=FALSE}
vecteur_c <- c(vecteur_a,27,vecteur_b) 
vecteur_c
```

Vecteurs - Indexation et sous-vecteur
========================================================
L'indexation en R commence à 1 contrairement à l'indexation en Python qui commence à 0.<br>
On peut récupérer un ou plusieurs éléments d'un vecteur avec l'opérateur `[` <br>

```{r message=FALSE, warning=FALSE}
vecteur_a
vecteur_a[1] #on commence à numéroter à partir de 1 (et non de zéro)
vecteur_a[c(1,3)]
```

Vecteurs - Fonctions de création de vecteurs
========================================================
Dans le cas où le vecteur correspond à une séquence de nombres, on peut utiliser une syntaxe particulière

```{r message=FALSE, warning=FALSE}
vecteur_a <- c(2,3,4) 
vecteur_b <- 2:4
vecteur_c <- seq(2,4,1) #seq(from = 2,to = 4,by = 1)  (à partir de 2, jusqu'à 4, avec un pas de 1)
```
Remarque, si on ne sait plus la signification des trois arguments de `seq`, on peut aller dans l'aide avec `?seq` <br>


Un vecteur peut également être généré à partir d'un tirage aléatoire

```{r message=FALSE, warning=FALSE}
vecteur_d <- sample(1:10,6)#sample(x = 1:10,size = 6) on tire 6 nombres dans le vecteur 1:10
vecteur_d
```

Cette fonction permet aussi de mélanger un vecteur
```{r message=FALSE, warning=FALSE}
sample(vecteur_d)
```


Vecteurs - Opérations simples
========================================================
Les opérations sur les vecteurs sont très proches des opérations sur les éléments. <br>
Une opération entre un vecteur a et un vecteur b revient à réaliser l'opération entre les couples d'éléments issus des deux vecteurs et situés à la même place (il faut que les vecteurs aient la même taille pour que ça ait un sens). <br>

```{r message=FALSE, warning=FALSE}
vecteur_a == vecteur_b # compare les éléments un à un
variable_logique_a <- vecteur_a == vecteur_b
```

Vecteurs - Opérations simples
========================================================
Si la taille d'un vecteur est multiple de la taille de l'autre, les opérations fonctionnent mais il faut en comprendre la logique.

```{r message=FALSE, warning=FALSE}
vecteur_e = sample(2:4,9,replace = T)
vecteur_e
vecteur_a
vecteur_e == vecteur_a # compare chaque élément à une même valeur
vecteur_e == 3
```

Cette souplesse du langage R est avantageuse mais peut être dangereuse en cas d'ambiguité.

Vecteurs - Opérations simples
========================================================
```{r message=FALSE, warning=FALSE}
vecteur_c
vecteur_c <- 2*vecteur_c # on écrase la valeur du vecteur_c
vecteur_c
vecteur_c + vecteur_a/2 # exemple d'opération entre deux vecteurs
```
Le vecteur d'entiers est devenu un vecteur de décimaux.

Vecteurs - Fonctions de base
========================================================
Le vecteur est caractérisé notamment par sa taille 

```{r message=FALSE, warning=FALSE}
length(vecteur_a)
```

Il peut-être trié :

```{r message=FALSE, warning=FALSE}
vecteur_d <- c(3,1,2,0)
ordre=order(vecteur_d)#Ceci nous donne l'ordre des indices
ordre
vecteur_d[ordre]
sort(vecteur_d)
```

Listes - Création
========================================================

```{r message=FALSE, warning=FALSE}
liste_a <- list(2,3,5)
liste_a
liste_a[[2]]
liste_b <- list(sexe = 2, age = 3, salaire = 5)
liste_b$salaire # si on donne des noms aux éléments de la liste, on peut les récupérer via l'opérateur $
```

Listes - Combinaison
========================================================

Pour concaténer deux listes 

```{r message=FALSE, warning=FALSE}
liste_a
liste_a <- append(liste_a, element_a) # ou liste_b à la place de element_a pour concaténer deux listes
liste_a
```

Listes - Liste de listes
========================================================

Pour concaténer deux listes 

```{r message=FALSE, warning=FALSE}
lliste_a <- list(liste_a, element_a) # ou liste_b à la place de element_a pour concaténer deux listes
lliste_a
```


Listes - Fonctions de bases
========================================================
La fonction `length` convient aussi pour les listes 

```{r message=FALSE, warning=FALSE}
length(liste_a)
```

On peut passer de la liste au vecteur avec la fonction `unlist()` <br>

```{r message=FALSE, warning=FALSE}
unlist(liste_a)
```

Tout est mis à plat, remarquer le comportement de `unlist()` pour la liste de listes.

```{r message=FALSE, warning=FALSE}
unlist(lliste_a)
```

Matrices - Création
========================================================
```{r message=FALSE, warning=FALSE}
matrice_a <- matrix(1:15,ncol=5) # exemple d'une matrice remplie des chiffres consécutifs de 1 à 15 rangés sur 5 colonnes 
matrice_a
head(matrice_a) # la fonction head permet de visualiser un extrait des données, ici elles sont petites donc c'est la totalité
matrice_a[1,2] # pour récupérer l'élément de la première ligne et de la deuxième colonne 
```

Matrices - Opérations simples
========================================================
Par défaut, les opérations mathématiques simples se font élément par élément 

```{r message=FALSE, warning=FALSE}
matrice_b <- 3*matrice_a
matrice_a
matrice_b
matrice_b - matrice_a # les opérations se font éléments par élément
``` 

Matrices - Fonctions de base
========================================================
Les dimensions de la matrice peuvent être obtenues de la manière suivante :

```{r message=FALSE, warning=FALSE}
nrow(matrice_a)
ncol(matrice_a)
dim(matrice_a)
```

Matrices - Fonctions de base
========================================================
Pour concaténer deux matrices, on peut 
<ul>
<li>Soit les mettre côte à côte (`cbind`). Ici c veut dire colonne. 
<li>Soit les empiler (`rbind`). Ici r veut dire row donc ligne.
</ul>
Ces fonctions fonctionnent aussi pour les data.frames.

```{r message=FALSE, warning=FALSE}
matrice_c <- cbind(matrice_a, matrice_b)
matrice_c
matrice_d <- rbind(matrice_a, matrice_b)
matrice_d
dim(matrice_d)
``` 

Matrices - Produits
========================================================
```{r message=FALSE, warning=FALSE}
matrice_b*matrice_a # cette opération réalise le produit élément par élément et non le produit matriciel. Les matrices doivent être de mêmes dimensions.
t(matrice_b)%*% matrice_a # pour faire des vrais produits matriciels, on utilise l'opérateur %*%, ici t() indique que l'on prend également la transposée
``` 




Data.frame - Création
========================================================
Les tables de données ou data.frame est sans doute le format qu'on utilisera le plus dans la suite. 

```{r message=FALSE, warning=FALSE}
df_a <- as.data.frame(matrice_a) # on commence par transformer la matrice en data.frame, l'opération symétrique as.matrix() est possible
head(df_a) 
names(df_a) # ici le data.frame provient de la conversion d'une matrice, il n'y a donc pas de noms de colonnes à part ceux qui sont donnés par défaut V1, V2...
names(df_a) <- c('a','b','c','d','e') # on peut changer le nom des colonnes simplement
names(df_a)
```

Data.frame - Indexation et extraction
========================================================

Pour récupérer de l'information dans la table de données, on peut procéder de différentes manières 

```{r message=FALSE, warning=FALSE}
df_a$b # avec l'opérateur $, on peut récupérer directement la colonne b
df_a[['b']] # revient au même
df_a[[2]] # correspond également car il s'agit de la 2e colonne
df_a$e <- 1 # permet de construire une nouvelle colonne e remplie de 1 
head(df_a)
```

Data.frame - Indexation et extraction
========================================================

```{r message=FALSE, warning=FALSE}
df_a$f <- df_a$a + df_a$b # permet de construire une nouvelle colonne qui serait la somme des deux premières, les opération -, *, /, sqrt pour racine carrée, log, exp, ^, sont également possibles ! 
head(df_a)
df_a$f <- sqrt(df_a$a) + df_a$b^2 # permet de construire une nouvelle colonne qui serait la somme des deux premières, les opération -, *, /, sqrt pour racine 
df_a$f
```

Formats en pratique
========================================================
Vérifions le type de ces objets avec la fonction `class`

```{r message=FALSE, warning=FALSE}
class(element_a)
class(vecteur_a)
class(variable_logique_a)
class(liste_a)
class(matrice_a)
class(df_a)
```

Environment - consultation et suppression
========================================================
`ls` = list segments
`rm` = remove

Ces verbes sont hérités de `bash`/`cmd`

Nous avons créé un certain nombre de variables qui sont disponibles dans votre environnement (généralement en haut à droite par défaut)
On peut aussi utiliser la fonction `ls` pour voir la liste des objets dont on dispose, et `rm` pour en supprimer.

```{r message=FALSE, warning=FALSE}
ls()
rm(element_a)
ls()
```

Boucles - Cas d'usage
========================================================
Reprenons le cas où on a un data.frame simple.<br>
On veut calculer la moyenne, la somme, le maximum et le minimum de chaque colonne. <br>
Une manière de le faire serait de faire une <b>boucle</b> sur le nombre de colonnes et d'appliquer la fonction 
<ul>
<li>`mean`
<li>`sum`
<li>`max`
<li>`min`
</ul>
à chaque colonne tour à tour.


Boucles - for (i in vec){fonction(i)}
========================================================
```{r message=FALSE, warning=FALSE}
nb_col <- ncol(df_a) 
mean_col <- NULL # on commence par créer une variable vide, dans laquelle on va ajouter itérativement les moyenne de chaque colonne
for (i in 1:nb_col){
  print(paste("numéro de la variable :",i))
  mean_temp <- mean(df_a[[i]])
  print(paste("moyenne de la variable i:",mean_temp))
  mean_col <- c(mean_col, mean_temp)
  print(paste("vecteur des moyennes",mean_col))
  print(paste("vecteur des moyennes",paste(mean_col,collapse = " ")))#Attention paste(), comme la plupart des fonctions R est vectorielle, elle essaie donc de s'appliquer au vecteur élément par élément
  print('---------')}
``` 


Boucles - apply(vec, fonction)
========================================================

En réalité, les boucles sont à éviter en R, elles ne sont pas efficaces.<br>
on leur préférera les fonctions de la famille `apply`. <br>
Par exemple la fonction `lapply` qui distribue la fonction souhaitée sur chaque élément d'une liste (et retourne une liste). Un data.frame peut-être vu comme une liste de vecteurs. 
<ul>
<li> apply sur un data.frame, s'applique sur les lignes, les colonnes ou chaque élément, essaie de renvoyer un data.frame
<li> lapply, l comme liste, essaie de renvoyer une liste.
<li> sapply, s comme simplify, plus souple que lapply.
<li> rapply, r comme recursif, version recursive de lapply.
<li> mapply pour une version multivariée de sapply.
</ul>


Boucles - sapply() et lapply()
========================================================
```{r message=FALSE, warning=FALSE}
mean_col <- sapply(df_a, mean) # sapply procède de même mais renvoie un vecteur
mean_col
mean_col <- lapply(df_a, mean) # ici la fonction est particulièrement simple car mean est déjà une fonction R
mean_col
```

Boucles - sapply() sur une fonction définie par l'utilisateur
========================================================
Admettons qu'on cherche à appliquer une fonction personnalisée 

```{r message=FALSE, warning=FALSE}
mean_personnalisee <- function(vect){
  return(sum(vect)/length(vect))
}
```


```{r message=FALSE, warning=FALSE}
mean_col <- sapply(df_a, function(vect) mean_personnalisee(vect))
mean_col
```

Boucles - lapply() sur une fonction définie par l'utilisateur
========================================================
Appliquée sur un vecteur, `lapply` le convertit en liste, on peut repasser à un format vecteur avec la fonction `unlist`

```{r message=FALSE, warning=FALSE}
fonction_personnalisee <- function(x){
  return(x*log(x))
}
```

```{r message=FALSE, warning=FALSE}
vecteur_a_transforme <- lapply(vecteur_a, function(x) fonction_personnalisee(x))
class(vecteur_a_transforme)
vecteur_a_transforme
unlist(vecteur_a_transforme)
vecteur_a*log(vecteur_a) # aurait marché aussi !
```

Boucles - apply() sur les lignes, les colonnes, les éléments
========================================================
`apply` s'applique aussi à des matrices, on indique alors si la fonction à distribuer doit être distribuée en ligne ou en colonne 

```{r message=FALSE, warning=FALSE}
matrice_a
apply(matrice_a,1,sum) # ici on applique la fonction somme, autrement dit on somme les éléments par ligne
apply(matrice_a,2,sum) # par colonne
apply(matrice_a,c(1,2),sqrt) # pour chaque élément
```

Condition - if() else()
========================================================

La syntaxe de la condition est très proche de celle de la boucle, sauf que l'on remplace `for` par `if`

```{r message=FALSE, warning=FALSE}
fonction_personnalisee <- function(x){
  if (x>0){res <- x*log(x)}
  else {res <- 0}
  return(res)
}
```

```{r message=FALSE, warning=FALSE}
vecteur_d <- c(10,0,-1,2)
sapply(vecteur_d, function(x) fonction_personnalisee(x))
abs(vecteur_d) # rmq : abs permet de passer un élément en valeur absolue (s'applique également aux vecteurs sans recours à lapply)
```

Ici on a inclus la condition dans une fonction, mais ce n'est pas indispensable ! <br>

Condition - if() else()
========================================================
On peut vouloir aussi tester la différence `!=` plutôt que l'égalité, `<` ou `>`, et si on a plusieurs conditions, on mettra chacune entre parenthèse et on utilisera `|` pour dire "ou" et `&` pour dire "et" (par exemple `(b-3==a) & (b>=a)`).
Parfois, on n'a pas besoin de passer par `if` pour appliquer une condition, par exemple si on veut récupérer seulement les éléments de vecteur_d supérieurs ou égaux à 0. Cela revient à dire qu'on teste la condition sur chaque élément et qu'on conserve vecteur_d[i] pour i tel que vecteur_d[i]>=0
 
```{r message=FALSE, warning=FALSE}
vecteur_d
vecteur_d[vecteur_d>=0]
```

Et ça fonctionne aussi avec les data.frames

```{r message=FALSE, warning=FALSE}
df_a[df_a$a>2] # on ne garde que les colonnes qui vérifient cette condition
```

Chaînes de caractères - Introduction
========================================================
Il arrive que les objets que l'on manipule ne soit pas numériques, on parle alors de `character` ou de `factor`. C'est le cas par exemple des noms de colonnes de `df_a`.<br>
Le format `character` est le format le plus souple et aussi le plus brouillon (non traité par la plupart des modèles lm, glm, gbm, randomforests...). <br>
Souvent lorsque le type d'une colonne n'est pas clair, R lui attribura le type character. 

```{r message=FALSE, warning=FALSE}
class(names(df_a))
```

On peut aussi réaliser des opérations, par exemple de concaténation. Imaginons que l'on souhaite préciser les noms de colonnes en indiquant qu'il s'agit de département.

```{r message=FALSE, warning=FALSE}
paste('departement','test',sep='_')
paste(rep('departement',5), names(df_a),sep='_') 
names(df_a) <- paste(rep('departement',5), names(df_a),sep='_') # revient à faire apply de paste sur tous les éléments du vecteur names(df_a)
rep('departement',5) # rep est la fonction qui permet de créer des vecteurs d'une taille donnée contenant toujours le même élément qui pourrait être numérique
```

Chaînes de caractères - Extraction substr() et strsplit()
========================================================
On peut récupérer une partie d'une chaine de caractère simplement 

```{r message=FALSE, warning=FALSE}
character_a <- 'departement_a' 
class(character_a)
substr(character_a,1,10) #les arguments correspondent à la chaine, au début de la sous-chaîne que l'on veut récupérer, et à la fin de la sous-chaîne que l'on veut récupérer
strsplit(character_a,'_') #les arguments correspondent à la chaine et au caractère qui au niveau duquel on veut couper
strsplit(character_a,'_')[[1]][[2]] #le résultat est une liste donc on utilise les doubles crochets pour récupérer l'élément qui nous intéresse
```

Chaînes de caractères - Taille nchar
========================================================
La taille d'une chaine de caractères correspond au nombre de caractères 

```{r message=FALSE, warning=FALSE}
nchar(character_a)
df_a$dep=c("Paris","Montpellier","Lyon")
df_a$dep_len=nchar(df_a$dep)
df_a[,c("dep","dep_len")]
```


Facteurs - Introduction
========================================================

Les facteurs correspondent aux modalités d'une variable qualitative. 

```{r message=FALSE, warning=FALSE}
col_df_a <- names(df_a)
col_df_a_fact <- as.factor(col_df_a)
is.character(col_df_a_fact)
class(col_df_a)
class(col_df_a_fact)
```


Facteurs - Quelques pièges (ajout de modalités)
========================================================

On ne peut pas rajouter un élément qui n'est pas dans la liste des facteurs naïvement 

```{r message=FALSE, warning=FALSE}
levels(col_df_a_fact) #liste des modalités de la variable factorielle
col_df_a_fact <- c(col_df_a_fact, 'departement_z')# attention cette opération a converti col_df_a_fact en character
class(col_df_a_fact) 
col_df_a_fact 
levels(col_df_a_fact) #Seuls les vecteurs de type factor sont vus comme des variables qualitatives
```

Facteurs - Quelques pièges (conversion)
========================================================
```{r message=FALSE, warning=FALSE}
col_df_a_fact <- as.factor(col_df_a)
as.character(col_df_a_fact) # parfois on préfère revenir aux chaines de caractères pour éviter ce type de problèmes 
```
Si une variable numérique est au format facteur et qu'on veut revenir au format numérique, il faut passer par le format character. Sinon on obtient le numéro de la modalité de chaque élément.
```{r message=FALSE, warning=FALSE}
fac <- factor(c(1,12,4,2,3,5))
levels(fac)
as.numeric(fac)
as.numeric(as.character(fac))
```

Génération d'aléa - tirage multinomial [sample]
========================================================
On a souvent besoin de générer des nombres aléatoires, par exemple pour tirer un échantillon dans les lignes d'une table, le plus simple est d'utiliser `sample` : 
 
```{r message=FALSE, warning=FALSE}
sample(1:100,10,replace=F) # on tire 5 éléments sans remise entre 1 et 100, l'argument replace = TRUE permet de faire un tirage avec remise.
```
On peut bien sûr pondérer le tirage

```{r message=FALSE, warning=FALSE, fig.align='center'}
tirage_pondere<-sample(1:100,10,replace=T,prob=(1/1:100)) #Ainsi on tire surtout des petits nombres
hist(tirage_pondere)
```

Génération d'aléa - tirage gaussien [rnorm]
========================================================

Il est parfois intéressant de simuler des données. Générons 50 observations tirées d'une variable suivant une loi normale de moyenne 20 et d'écart-type 10.
 
```{r message=FALSE, warning=FALSE}
set.seed(123) # permet de reproduire les mêmes résultats d'une fois sur l'autre en dépit de l'aléa présent
n <- 50
Y <- rnorm(n,20,5)

mean(Y) # moyenne empirique
sd(Y) # écart-type empirique
sd(Y)/sqrt(length(Y)) # écart-type de la moyenne empirique

summary(Y) # quartiles et moyenne empiriques
```
Génération d'aléa - visualisation du tirage [boxplot]
========================================================
On peut représenter graphiquement cette variable 
 
```{r message=FALSE, warning=FALSE, fig.align='center'}
boxplot(Y) # diagramme boîte
```


Génération d'aléa - visualisation du tirage [hist & lines & curves]
========================================================
```{r message=FALSE, warning=FALSE, fig.align='center'}
hist(Y, probability=T, col="blue") # histogramme de la densité
lines(density(Y), col="red", lwd=2) # lissage de l'histogramme
# tracer la loi théorique
x <- 1:100
curve(dnorm(x,mean=20,sd=5),add=TRUE,col="green",lwd=2) # l'argument add permet de rajouter cette courbe sur le même graphique, il s'agit de la distribution théorique
```

Génération d'aléa - tirage uniforme [runif]
========================================================
On peut générer des observations tirées dans une loi uniforme sur [a,b]
 
```{r message=FALSE, warning=FALSE, fig.align='center'}
X <- runif(n,50,100)
hist(X)
```

Vous pouvez augmenter la valeur de `n` pour voir ce que ça donne 


Exercice sur des données - Introduction
========================================================

Pour cette entrée en matière de l'exploration d'un vrai fichier de donnée, nous nous sommes fortement inspirés de l'exercice suivant https://www.math.univ-toulouse.fr/~besse/Wikistat/pdf/st-scenar-statlab.pdf

Une  étude réalisée  entre  1961  et  1973  dans  la  maternité  d'un  hôpital d'Oakland  (Californie)  avait  pour  but  de  rechercher  si  certaines  caractéristiques  des  parents  avaient  une  influence  sur  le  développement  de  l'enfant. Parmi les variables collectées, 19 variables décrites dans le tableau ci-dessous ont  été  observées  sur  115  familles  ou  unités  statistiques.  Ces  variables  décrivent des informations médicales et socio-économiques concernant le bébé et ses parents au moment de la naissance puis dix ans plus tard, permettant ainsi de se poser différentes questions de nature plutôt épidémiologique :

-  Influence ou non de la consommation de cigarettes sur le sexe de l'enfant, sur son poids, sur sa taille,
-  sur l'évolution du poids de la mère en 10 ans,
-  sur les liaisons entre les caractéristiques des parents (poids, taille, rhésus) et celles de leur enfant

<center><img src="list_var.png"/></center>

Chargement de données [read.csv2]
========================================================
```{r message=FALSE, warning=FALSE}
famil=read.csv2("statlab.csv") # lecture du fichier csv
head(famil) # aperçu du haut des données
```

Aperçu des données [summary & dim]
========================================================
```{r message=FALSE, warning=FALSE}
dim(famil) # combien de colonnes et de ligne 
summary(famil) # quelques statistiques classiques
```
La fonction `summary` fournit déjà beaucoup d'information sur chaque variable. Mais on pourrait réappliquer les fonctions moyenne, écart-type, quantiles, diagramme boîte, histogramme, indépendamment, sur toutes les variables ou certaines en particulier. 

Aperçu des données quanti [sapply & mean & sd]
========================================================
```{r message=FALSE, warning=FALSE}
sapply(famil, mean) # les moyennes de chaque variable 
sapply(famil, function(x) mean(x,na.rm = T)) # les moyennes de chaque variable en ignorant les valeurs manquantes
sapply(famil, sd) # les écarts type
```

Visualisation Univariée quanti [boxplot]
========================================================
```{r message=FALSE, warning=FALSE,fig.align="center",fig.width=20}
boxplot(famil$ET0) # taille de l'enfant
```

Visualisation Univariée quanti [hist]
========================================================

```{r message=FALSE, warning=FALSE,fig.align="center",fig.width=20}
hist(famil$EP0)# poids de l'enfant
```


Visualisation Univariée quali [table & barplot]
========================================================
Pour les variables qualitatives, on aura plutôt tendance à considérer les fréquences des modalités.

```{r message=FALSE, warning=FALSE,fig.align="center",fig.width=20}
table(famil$ESx)
barplot(table(famil$ESx)) # sexe de l'enfant

```

Visualisation Univariée quali [hist]
========================================================
Pour les variables qualitatives, on aura plutôt tendance à considérer les fréquences des modalités.

```{r message=FALSE, warning=FALSE,fig.align="center",fig.width=20}
barplot(table(famil$MCig0)) # consommation de cigarettes
```

Visualisation Univariée quali [pie]
========================================================
Pour les variables qualitatives, on aura plutôt tendance à considérer les fréquences des modalités.

```{r message=FALSE, warning=FALSE,fig.align="center",fig.width=20}
pie(table(famil$MCig10)) # consommation de cigarettes dix ans après 
```

Visualisation Bivariée quanti [pairs]
========================================================

Pour analyser grossièrement les liaisons, on peut regarder un nuage de points 

```{r message=FALSE, warning=FALSE,fig.align="center",fig.width=20}
pairs(famil[,c(3:6,8,9,11)])
```

Visualisation Bivariée quanti [plot]
========================================================

```{r message=FALSE, warning=FALSE,fig.align="center",fig.width=20}
plot(EP10~PP10,data=famil) # poids de l'enfant à 10 ans, poids du père
```
Visualisation Bivariée quanti [plot & lm & abline]
========================================================

On peut facilement ajouter la droite de regression

```{r message=FALSE, warning=FALSE,fig.align="center",fig.width=20}
plot(EP10~ET10,data=famil) # poids de l'enfant à 10 ans, taille à 10 ans
abline(lm(EP10 ~ ET10,data = famil))
```

Analyse Bivariée quali [table & addmargins]
========================================================

Pour analyser grossièrement les liaisons entre variables qualitatives, on aura recours aux tables de contingence 

```{r message=FALSE, warning=FALSE}
table(famil$ESx,famil$ERh) # sexe et rhésus
addmargins(table(famil$ESx,famil$ERh)) # avec les marges
```

Visualisation Bivariée quali [mosaicplot]
========================================================
Une manière de représenter graphiquement ces tables est d'utiliser une moisaique

```{r message=FALSE, warning=FALSE,fig.align="center",fig.width=20}
prop.table(table(famil$ESx,famil$ERh)) # fréquences relatives
mosaicplot(table(famil$ESx,famil$ERh))
```


Visualisation Bivariée quali [mosaicplot]
========================================================

```{r message=FALSE, warning=FALSE,fig.align="center",fig.width=20}
addmargins(table(famil$MCig0,famil$ESx)) # consommation de cigarette et sexe de l'enfant
mosaicplot(table(famil$MCig0,famil$ESx))
```

Visualisation Bivariée quali x quanti [boxplot]
========================================================

Si l'on veut croiser variables qualitatives et quantitatives, on peut utiliser les boites 

```{r message=FALSE, warning=FALSE,fig.align="center",fig.width=20}
boxplot(EP0~ESx,data=famil) # poids de l'enfant vs sexe
```

Visualisation Bivariée quali x quanti [boxplot]
========================================================

```{r message=FALSE, warning=FALSE,fig.align="center",fig.width=20}
boxplot(EP0~MCig0,data=famil) # poids de l'enfant vs consommation de cigarettes
```

Manipulation des données - ordre des modalités
========================================================
Remarque, les modalités de `Mcig0` ne sont pas dans l'ordre le plus naturel, on peut décider de réordonner les modalités.

```{r message=FALSE, warning=FALSE,fig.align="center",fig.width=20}
famil$MCig0 <- factor(famil$MCig0, levels = c("0cig", "1-10cig", ">10cig"))

famil$MCig10 <- factor(famil$MCig10, levels = c("0cig", "1-10cig", ">10cig"))
boxplot(EP0~MCig0,data=famil) # poids de l'enfant vs consommation de cigarettes
```


Test de liaison [chisq.test]
========================================================

Quelques tests, imaginons qu'on veuille tester l'indépendance de deux variables qualitatives. Le test du $\chi^2$ sera adapté à ce problème (dans le cas 
où les effectifs d'une modalité sont trop faibles, il faut regrouper les modalités). 

```{r message=FALSE, warning=FALSE}
chisq.test(table(famil$ESx,famil$ERh)) # Sexe de l'enfant vs Rhésus
chisq.test(table(famil$ESx,famil$MCig0)) # Sexe de l'enfant vs consommation de cigarettes
```

Test de liaison [shapiro.test]
========================================================
On s'intéresse à l'influence du sexe sur la taille à la naissance. Tester l'égalité des deux moyennes nécessite de vérifier préalablement plusieurs points : la normalité des distributions dans chaque classe à moins que l'échantillon soit considéré de taille suffisamment grande, le caractère indépendant ou appariés des échantillons, l'égalité ou non des variances à l'intérieur de chaque groupe. On dispose de deux échantillons indépendants : les garçons et les filles. Testons les autres hypothèses.

```{r message=FALSE, warning=FALSE}
# Normalité des distributions (facultatif car n grand ici)
shapiro.test(famil[famil$ESx=="M","ET0"]) 
shapiro.test(famil[famil$ESx=="F","ET0"])
# égalité des variances (test de Fisher)
var.test(ET0~ESx,data=famil)
```

Test de liaison [t.test]
========================================================
Le test de comparaison des moyennes à utiliser (Student vs. Welsh) dépend du résultat précédent concernant l'égalité des variances.

```{r message=FALSE, warning=FALSE}
t.test(ET0~ESx,var.equal=F, data=famil) # si les variances sont différentes c'est un test de Welsh

t.test(ET0~ESx,var.equal=T, data=famil) # Dans le cas où elles sont considérées égales, c'est un test de Student.
```

Test de liaison [t.test]
========================================================
Dans le cas d'échantillons appariés, par exemple si on se propose d'étudier l'évolution du poids de la mère au moment de la naissance et dix ans après, on utilise l'option `paired=TRUE`

```{r message=FALSE, warning=FALSE}
t.test(famil$MP0, famil$MP10,paired=TRUE)
```

Test de liaison - Remarques
========================================================

- si l'hypothèse de normalité des distributions n'est pas vérifiée et si l'échantillon est trop réduit, c'est un test non-paramétrique qu'il faut mettre en ouvre. Les tests non-paramétriques sont basés sur les rangs des observations et donc sur les comparaisons des médianes des échantillons (wilcoxson). 

- Si l'on veut tester l'indépendance entre une variable qualitative et quantitative, l'ANOVA associée à un test de Fisher est sans doute le test le plus utilisé ; il revient au test de Student lorsque la variable qualitative n'a que deux modalités.

Régression linéaire - modèle [lm]
========================================================
La régression simple permet de tester l'influence éventuelle d'une variable sur une autre et plus précisément, dans le cas de cet exemple, d'expliquer la taille  de  l'enfant  à  10  ans. On estime le modèle avec la fonction `lm`  


```{r message=FALSE, warning=FALSE}
res1.reg <- lm(ET10 ~ PT, data = famil)
names(res1.reg) # liste des résultats
```

Régression linéaire - Visualisation [qqnorm & qqline]
========================================================
Les graphiques suivants permettent de s'assurer de la validité du modèle, et notamment de statuer sur l'homoscédasticité des résidus, leur normalité, la bonne linéarité du modèle.

```{r message=FALSE, warning=FALSE,fig.align="center",fig.width=20}
qqnorm(res1.reg$residuals) # normalité des résidus
qqline(res1.reg$residuals)
```


Régression linéaire [shapiro.test]
========================================================

```{r message=FALSE, warning=FALSE,fig.align="center",fig.width=20}
shapiro.test(res1.reg$residuals) 
```

Régression linéaire [rstudent]
========================================================
Les résidus sont "grands" si, une fois normalisés ou plutôt "studentisés", ils sont de valeur absolue plus grande que 2. 

```{r message=FALSE, warning=FALSE,fig.align="center",fig.width=20}
res.student <- rstudent(res1.reg)
ychap=res1.reg$fitted.values
plot(res.student~ychap,ylab="Résidus") 
abline(h=c(-2,0,2),lty=c(2,1,2)) # rajoute une ligne horizontale
```

Régression linéaire [cook.distance]
========================================================
Une observation est influente si elle a un grand résidu est est associée à une grande valeur sur la diagonale de la hat matrix. Cela correspond à une valeur élevée (plus grande que 1) de la distance de Cook.

```{r message=FALSE, warning=FALSE,fig.align="center",fig.width=20}
cook <- cooks.distance(res1.reg) # repérage de points influents
plot(cook~ychap,ylab="Distance de Cook")
abline(h=c(0,1),lty=c(1,2))
```

Régression linéaire - significativité [summary]
========================================================

La significativité du modèle peut être analysée via la fonction `summary` : 

```{r message=FALSE, warning=FALSE}
summary(res1.reg)
```

Régression linéaire multivarié - significativité [plot]
========================================================
La régression linéaire simple conduit à un modèle très mal ajusté. Le modèle linéaire multiple ci-dessous, plus complexe, recherche un meilleur ajustement des données.

```{r message=FALSE, warning=FALSE}
res2.reg <- lm(ET10~ET0+EP0+MA0+MP0+MT+MP10+PA0+PT+PP10+RF0+RF10, data = famil)
plot(res2.reg) # diagnostics des résidus
```

Régression linéaire multivarié - significativité [summary]
========================================================

```{r message=FALSE, warning=FALSE}
summary(res2.reg) # résultats 
```

Réduction de dimension [ACP]
========================================================
On peut aller plus loin dans l'exploration sur les données sans fixer une variable cible, en réalisant une analyse en composantes principales. On ne garde que les variables quantitatives.  

Pour cela, on va faire appel à la librairie `prcomp`, ce n'est pas la seule qui permet de faire une ACP. Assez régulièrement sous R, on va avoir besoin de mobiliser des packages ou librairies. La  liste  complète  des packages disponibles gratuitement est consultable sur le site du CRAN. L'installation d'un package supplémentaire peut se faire via le menu Packages>Installer le(s) package(s) et en choisissant un site miroir du CRAN. On peut également télécharger l'archive .zip correspondant au package et utiliser ensuite Packages/Installer depuis des fichiers zip

On peut sinon taper la commande :

```{r message=FALSE, warning=FALSE}
# if (!require("factoextra"))install.packages('factoextra') # décommenter pour installer
```

ACP en pratique [prcomp et plot]
========================================================

http://www.sthda.com/french/articles/38-methodes-des-composantes-principales-dans-r-guide-pratique/79-acp-dans-r-prcomp-vs-princomp/

```{r message=FALSE, warning=FALSE,fig.align="center",fig.width=20}
data <- famil[,c(3:6,8,9,11,12,14,16:19)] # liste des varaibles quantitatives
noms <- names(data)
res.pca <- prcomp(data,scale=T)
# plot(res.pca) # décroissance des valeurs propres
factoextra::fviz_eig(res.pca)
```


ACP en pratique [summary]
========================================================

```{r message=FALSE, warning=FALSE,fig.align="center",fig.width=20}
summary(res.pca) # parts de variance expliquée
```

ACP en pratique [plot & text & abline]
========================================================

```{r message=FALSE, warning=FALSE,fig.align="center",fig.width=20}
plot(res.pca$x,col=c('black','red','green')[famil$MCig0]) # les observations sont représentées dans le plan des deux composantes principales résumant le mieux l'information contenue dans les données, la couleur permet de distinguer la consommation de cigarette (noir pour la consommation la plus élevée) 
text(10*res.pca$rotation,noms,col="blue") # on peut afficher également les variables pour interpréter les axes, on voit que l'axe vertical rend surtout compte des revenus tandis que l'axe horizontal est plus lié à la taille et au poids de l'enfant et des parents. 
abline(h=0,v=0,lty=2)
```

ACP en pratique - individus sur PC1 & PC2
========================================================

```{r message=FALSE, warning=FALSE,fig.align="center",fig.width=20}
factoextra::fviz_pca_ind(res.pca,
             col.ind = "cos2", # Colorer par le cos2
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE     
             )
```

ACP en pratique - variables sur PC1 & PC2
========================================================

```{r message=FALSE, warning=FALSE,fig.align="center",fig.width=20}

factoextra::fviz_pca_var(res.pca,
             col.var = "contrib", 
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE     
             )
```

ACP en pratique - biplot sur PC1 & PC2
========================================================
```{r message=FALSE, warning=FALSE,fig.align="center",fig.width=20}
factoextra::fviz_pca_biplot(res.pca, repel = TRUE,
                col.var = "#2E9FDF", 
                col.ind = "#696969"  
                )
```

ACP en pratique - ind et groupes sur PC1 & PC2
========================================================
```{r message=FALSE, warning=FALSE,fig.align="center",fig.width=20}
groups <- (factor(data$PA0>30))
levels(groups)<-c("Low","High")
factoextra::fviz_pca_ind(res.pca,
             col.ind = groups, # colorer par groupes
             palette = c("#00AFBB",  "#FC4E07"),
             addEllipses = TRUE, # Ellipse de concentration
             ellipse.type = "confidence",
             legend.title = "Groups",
             repel = TRUE
             )
```

Exploration des données d'urgence - Intro
========================================================
Cet exercice mobilise l'enquête nationale sur les structures des urgences hospitalières 2013. Un jour donné, le 11 juin 2013 de 8h à 8h le 
lendemain, un questionnaire papié renseigné en temps réel en parallèle de la prise en charge par tous les points d'accueils (736) des établissements de santé autorisés pour l'activité d'accueil et de traitement des urgences (634) et pour tous les patients (52018). 

Exploration des données d'urgence - Chargement [csv] et aperçu
========================================================
```{r message=FALSE, warning=FALSE}
urgences <- read.csv2("enq_urgences_structure.csv", sep=',') # lecture du fichier csv
head(urgences,2) # aperçu du début des données
dim(urgences) # combien de colonnes et de lignes 
#names(urgences)
dim(urgences)
```

Exploration des données d'urgence - Chargement [xls] et aperçu
========================================================
Remarque, si le fichier était au format xls, on pourrait l'ouvrir, par exemple, avec le package `xlsx`
```{r message=FALSE, warning=FALSE,eval=F}
library("xlsx")
urgences2 <- read.xlsx("enq_urgences_structure.xls",1) # 1 correspond ici à la page 1 de l'excel
head(urgences2) # aperçu du haut des données
dim(urgences2)
```

Exploration des données d'urgence - Dictionnaire
========================================================
Pour chaque heure de pointage (8h, 12h, 18h, 22h, 8h) indiquée par les lettres A, B, C, D, E, on retient pour l'exercice les variables suivantes (cf questionnaire dans le dossier de la formation) :

Les variables de présence de patients aux urgences :

- 87 : Nombre de patients en cours d'évaluation, non admis (nombre de patients présents hors lit i.e. box, salle d'attente) pour lesquels une décision d'hospitalisation n'a pas été prise
- 88 : Nombre de patients admis et en attente d'hospitalisation sur un brancard ou un fauteuil roulant (« boarding »)
- 89 : Nombre de patients présents en lit (UHCD) qui ne sont pas en attente d'hospitalisation
- 90 : Nombre de patients présents en lit (UHCD) en attente d'hospitalisation

Exploration des données d'urgence - Dictionnaire
========================================================

Les variables d'organisation du travail : 

- 92 : Nombre de médecins urgentistes
- 93 : Nombre de médecins non urgentistes
- 94 : Nombre d'interne
- 95 : Nombre de médecins intérimaires et extérieurs
- 96 : Nombre de cadres de santé
- 97 : Nombre d'infirmiers diplômés d'État (IDE)
- 98 : Nombre d'aide soignants(AS)
- 99 : Nombre d'agents de service hospitalier (ASH)
- 100 : Nombre de secrétaires 
- 101 : Nombre de brancardiers

Les variables liées à l'établissement :

- A103 : Nombre de passages sur les 24 heures
- A4 : type d'accueil
- A2 : numéro finess de l'établissement

Nettoyage des données
========================================================
Pour ne garder que ces variables là, on reconstruit les noms des variables pour chaque heure de pointage. Par exemple, la variable 98 : nombre d'aide soignant, va être présente cinq fois : "ID_A87", "ID_B87", "ID_C87", "ID_D87", "ID_E87". On va utiliser `lapply` et `paste` (qui concatène les chaines de caractères) pour reconstituer tous les noms de variables qu'on veut garder pour toutes les heures de pointages. `rep` est une fonction qui répète plusieurs fois le même élément.
```{r message=FALSE, warning=FALSE}
col_a_garder <- c(87:90,92:101)
nbcol <- length(col_a_garder)
paste(rep('ID_',nbcol),rep('A',nbcol),col_a_garder,sep='') # génère la liste des variables pour la première heure de pointage

col_a_garder <- unlist(lapply(c('A','B','C','D','E'), function(lettre) paste(rep('ID_',nbcol),rep(lettre,nbcol),col_a_garder,sep=''))) # génère les 5 listes de variables en une seule ligne de code
col_a_garder <- c(col_a_garder, "ID_A103","ID_A4","ID_A2")
urgences <- urgences[,col_a_garder]
dim(urgences)
```

Répartition des types d'établissement
========================================================

```{r message=FALSE, warning=FALSE}
table(urgences$ID_A4) # répartition des structures
```


Distribution des volumes de passages
========================================================
On va regarder la distribution du nombre de passages total dans les établissements, c'est un proxy de la taille de ces derniers. On va créer des modalités pour identifier les services d'urgences comparables. Pour les graphiques, on va désormais utiliser la librairie `ggplot2`, installez-là si elle n'est pas installée. `aes` permet de définir les variables qui vont être utilisées.

```{r message=FALSE, warning=FALSE,fig.align="center",fig.width=20}
library(ggplot2)
ggplot(urgences, aes(x=ID_A103)) + geom_histogram(fill="blue", alpha=0.4) + ggtitle("distribution du nombre de passages") # alpha gère la transparence 
```

Distribution ventilée par type de structure
========================================================
```{r message=FALSE, warning=FALSE,fig.align="center",fig.width=20}
p <- ggplot(urgences, aes(x=ID_A103, fill = ID_A4)) + geom_histogram(alpha=0.4) + theme(legend.position="top") # en précisant la couleur par un nom de variable, on demande le tracé d'un histogramme pour chaque modalité 
p
```


Graphique dynamique avec [ggplotly]
========================================================
Avec la fonction `ggplotly` de `plotly` on peut rendre le graphique interactif.

```{r message=FALSE, warning=FALSE}
library(plotly)
p<-ggplotly(p)#https://stackoverflow.com/questions/41187823/error-in-filecon-rb-cannot-open-the-connection-when-generating-a-plot-in
htmlwidgets::saveWidget(as.widget(p), file = "volume_de_patients.html")#Cette ligne de code et l'iframe en dessous permettent de faire fonctionner plotly dans le contexte de la presentation
```
<iframe src="volume_de_patients.html" style="position:absolute;height:100%;width:100%"></iframe>

Suppression des valeurs manquantes [na.omit]
========================================================
On va désormais transformer cette variable en variable qualitative pour rassembler les établissements de taille similaire 

```{r message=FALSE, warning=FALSE}
valeurs_manquantes <- is.na(urgences$ID_A103) # on regarde si la variable admet des valeurs manquantes, 
head(valeurs_manquantes)
(TRUE %in% valeurs_manquantes) # c'est le cas 
sum(valeurs_manquantes) # nb de valeurs manquantes
dim(urgences)
urgences <- na.omit(urgences) # si on veut retirer toutes les lignes avec au moins une valeur manquante (pas toujours souhaitable)
dim(urgences)
```

Regroupement des établissements par volume de patients [cut]
========================================================
```{r message=FALSE, warning=FALSE}
# on crée une nouvelle colonne
urgences$nb_passages_3 <- cut(urgences$ID_A103, breaks = c(0,40,80,max(urgences$ID_A103, na.rm=T))) # max, comme la plupart des fonctions renverra une erreur si appliqué sur un vecteur contenant des NA, on les enlève pour le calcul avec l'option na.rm 
table(urgences$nb_passages_3)
```



Volume de patient ventilé par tranche horaire [prep]
========================================================
On voudrait maintenant regarder le nombre de patients ou les effectifs par tranche horaire, on voit bien qu'il serait plus facile d'avoir une variable tranche horaire que de considérer des colonnes différentes contenant tantôt un A, un B, un C etc... On va récupérer les colonnes correspondant à chaque horaire, les renommer, puis de les empiler en créant une colonne horaire 

```{r message=FALSE, warning=FALSE}
horaire_8 <- urgences[,c(paste('ID_','A',c(87:90,92:101), sep =''),'ID_A103','ID_A4','nb_passages_3','ID_A2')] # sélection des colonnes contenant un A pour chaque établissement
horaire_12 <- urgences[,c(paste('ID_','B',c(87:90,92:101), sep =''),'ID_A103','ID_A4','nb_passages_3','ID_A2')]
horaire_18 <- urgences[,c(paste('ID_','C',c(87:90,92:101), sep =''),'ID_A103','ID_A4','nb_passages_3','ID_A2')]
horaire_22 <- urgences[,c(paste('ID_','D',c(87:90,92:101), sep =''),'ID_A103','ID_A4','nb_passages_3','ID_A2')]
horaire_8_ <- urgences[,c(paste('ID_','E',c(87:90,92:101), sep =''),'ID_A103','ID_A4','nb_passages_3','ID_A2')]
head(horaire_8)
```

Volume de patient ventilé par tranche horaire [prep]
========================================================
```{r message=FALSE, warning=FALSE}

#on rajoute une colonne d'heure 
horaire_8$heure <- '8h'
horaire_12$heure <- '12h'
horaire_18$heure <- '18h'
horaire_22$heure <- '22h'
horaire_8_$heure <- '8h_'

#pour pouvoir empiler les 5 tables il faut qu'elles aient les mêmes noms de colonnes 
names(horaire_8) <- c(paste('ID_',c(87:90,92:101), sep =''),'ID_A103','ID_A4','nb_passages_3','ID_A2','heure')
names(horaire_12) <- c(paste('ID_',c(87:90,92:101), sep =''),'ID_A103','ID_A4','nb_passages_3','ID_A2','heure')
names(horaire_18) <- c(paste('ID_',c(87:90,92:101), sep =''),'ID_A103','ID_A4','nb_passages_3','ID_A2','heure')
names(horaire_22) <- c(paste('ID_',c(87:90,92:101), sep =''),'ID_A103','ID_A4','nb_passages_3','ID_A2','heure')
names(horaire_8_) <- c(paste('ID_',c(87:90,92:101), sep =''),'ID_A103','ID_A4','nb_passages_3','ID_A2','heure')

urgences2 <- rbind(horaire_8, horaire_12, horaire_18, horaire_22, horaire_8_) # on les empile avec rbind
dim(urgences)
dim(urgences2)
head(urgences2)
```

Volume de patient ventilé par tranche horaire [prep]
========================================================
```{r message=FALSE, warning=FALSE,eval=F}
# on va remplacer les variables 'ID_A103', 'ID_A4' et 'ID_A2' par des noms de variables intelligibles
names(urgences2)[names(urgences2)=='ID_A103'] <- 'nb_passages'
names(urgences2)[names(urgences2)=='ID_A4'] <- 'type_structure'
names(urgences2)[names(urgences2)=='ID_A2'] <- 'index_structure'
```

Voici l'equivalent dplyr
```{r message=FALSE, warning=FALSE}
urgences2 <- urgences2%>%rename(nb_passages=ID_A103,type_structure=ID_A4,index_structure=ID_A2)
```

Volume de patient ventilé par tranche horaire [ggplot]
========================================================
On peut regarder le nombre de médecins urgentistes `ID_92` en fonction de la tranche horaire et de la taille de la structure avec un graphique à boites.
```{r message=FALSE, warning=FALSE}
# sapply(urgences2, class) #attention certaines variables numériques ne sont pas considérées comme telles !
urgences2[,1:15] <- lapply(urgences2[,1:15],function(v) as.numeric(as.character(v))) # on les convertit
p<-ggplot(data = urgences2, aes(x=heure, y=ID_92, color=nb_passages_3)) + geom_boxplot() + ylab('Effectif de médecin urgentiste')
```
```{r message=FALSE, warning=FALSE,echo=F}
p<-ggplotly(p)
htmlwidgets::saveWidget(as.widget(p), file = "effectif_urgentiste.html")
```
<iframe src="effectif_urgentiste.html" style="position:absolute;height:100%;width:100%"></iframe>


Volume de patient ventilé par tranche horaire [dplyr group_by & summarise]
========================================================

Si on veut plutôt regarder l'évolution du nombre moyen de médecins urgentistes dans des établissements de taille similaire au cours de la journée, il va falloir d'abord calculer cette moyenne par groupe (les groupes étant identifiés par les 3 classes construites précédemment en rendant qualitative la variable des nombres de passages et par l'heure de pointage). Pour cela on va faire appel au package `dplyr`, vous devez l'installer si ce n'est pas déjà fait.

```{r message=FALSE, warning=FALSE}
grouped <- group_by(urgences2, heure, nb_passages_3)
grouped_mean <- summarise(grouped, mean=mean(ID_92, na.rm = T))
head(grouped_mean)

# les deux actions peuvent être réalisées dans la foulée avec l'opérateur %>%
grouped_mean <- urgences2 %>% group_by(heure, nb_passages_3) %>% summarise(mean=mean(ID_92, na.rm = TRUE))
head(grouped_mean)
```


Volume de patient ventilé par tranche horaire [ggplot]
========================================================
```{r message=FALSE, warning=FALSE,fig.align="center",fig.width=20}
                                                                                        
ggplot(data = grouped_mean, aes(x=heure, y=mean, group = nb_passages_3, color = nb_passages_3)) + geom_line() + geom_point()
```
Remarque : les fonctionnalités du packages `dplyr` sont bien plus riches, allez jeter un oeil à la cheatsheet data wrangling french fournie dans le dossier de la formation.


Ventilation par type de personnel de soin [prep]
========================================================
Maintenant on va regarder l'évolution de la distribution des effectifs de personnels dans le temps, sans se limiter aux médecins urgentistes. Pour présenter les différents graphiques côte à côte, on va utiliser l'option `facet` de `ggplot2` mais avant cela, il faut retravailler encore la forme des données. Commençons par regarder les distributions d'effectifs de professionnels, donc les variables de 90 à 101, que l'on va rendre plus intelligible dans un premier temps.

```{r message=FALSE, warning=FALSE}
urgences_ps <- urgences2[,c('index_structure','nb_passages_3','heure','ID_90','ID_92','ID_93','ID_94','ID_95','ID_96','ID_97','ID_98','ID_99','ID_100','ID_101')]
names(urgences_ps)[4:length(urgences_ps)] <-c('med urgentistes', 'med non urgentistes','internes','médecins int et ext', 'cadres','IDE','AS','ASH','secrétaires','brancardiers') # on rend les colonnes plus intelligibles
library(reshape)
urgences_ps <- melt(urgences_ps, id=c("index_structure","nb_passages_3",'heure')) 
head(urgences_ps)
names(urgences_ps)[4:5] <-c('PS','effectif')
head(urgences_ps)
```

Ventilation par type de personnel de soin [facet]
========================================================
On a donc créé une variable PS (pour professionnel de santé) qui prend plusieurs modalités et on a, pour chaque structure d'urgence identifiée par l'identifiant ID_A2, une ligne par profession avec les effectifs correspondants. Cette représentation rend la représentation graphique quasi immédiate avec `ggplot2`

```{r message=FALSE, warning=FALSE,fig.align="center",fig.width=20}
urgences_ps$heure = factor(urgences_ps$heure , levels=c("8h", "12h", "18h", "22h", "8h_")) # on transforme la variable en facteur et on ordonne les heures
ggplot(urgences_ps, aes(x=PS, y=effectif, fill=PS)) + geom_bar(stat = "identity") + facet_grid(as.factor(heure) ~ nb_passages_3) + theme(axis.ticks.x=element_blank(),axis.text.x=element_blank())
# theme permet de retirer la légende sous l'axe des x, si vous retirez ce bout de code vous verrez la différence
# facet_grid permet de produire plusieurs graphiques en fixant une variable ici le nombre de passage ou l'heure de pointage
```

Variante - EXERCICE
========================================================
<b>Le même exercice peut être réalisé pour la distribution des types de patients, à vous de jouer</b>

Ouvrir une table SAS
========================================================
Enfin, nous allons représenter la répartition géographique des structures d'urgence en France. Pour cela nous allons utiliser la table sas `ej.sas7bdat` qui relie les codes FINESS des établissements avec leurs coordonnées géographiques. Cette base est stockée dans un format SAS, on va utiliser la librairie `haven` pour la lire.   

```{r message=FALSE, warning=FALSE}
library(haven)
ej <- read_sas(data_file = 'ej.sas7bdat')
head(ej)
```

Preparation des données à cartographier
========================================================
Pour tracer sur une carte les structures d'urgence de notre table `urgences`, on va apparier notre table avec `ej`, sur la clé `finess` et `ID_A2` respectivement. On va bien faire attention à garder tous les codes finess de la base `urgences`

```{r message=FALSE, warning=FALSE}
urgences_loc <- merge(urgences[,c('ID_A2','ID_A4','ID_A103')],ej,by.x = 'ID_A2',by.y = 'finess', all.x = TRUE) #on garde aussi le type de structure et le nombre de passages
head(urgences_loc)
dim(urgences)
dim(urgences_loc)
dim(ej)
```

Attention geocoding imparfait
========================================================
type : alert
Le fait d'avoir indiqué l'option `all.x = TRUE` force à garder toutes les lignes de `urgences` même quand il n'existe pas de match possible. Ici certains codes finess ne semblent pas avoir de coordonnées géographiques disponibles. On ne va conserver que les structures qui ont des coordonnées grâce à `na.omit` 
```{r message=FALSE, warning=FALSE}
urgences_loc_sans_na <- na.omit(urgences_loc)
dim(urgences_loc_sans_na)
```
Seulement la moitié des structures sont géocodées
On va regarder la répartition des structures d'urgence par type de structure (repéré par la variable `ID_A4`).
La représentation de points sur une carte nécessite de maîtriser le concept de projection : https://medium.com/@_FrancoisM/introduction-%C3%A0-la-manipulation-de-donn%C3%A9es-cartographiques-23b4e38d8f0f.

Cartographie avec Leaflet - code
========================================================
```{r message=FALSE, warning=FALSE}
library(leaflet)
library(rgdal)
urgences_loc_sans_na <- na.omit(urgences_loc)

# Ce bloc permet de convertir les coordonnées en Lambert 93 en WGS 84 plus traditionnel
coordinates(urgences_loc_sans_na) <- c("X", "Y")
proj4string(urgences_loc_sans_na) <- CRS("+init=epsg:2154") # WGS 84
CRS.new <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
urgences_loc_sans_na <- spTransform(urgences_loc_sans_na, CRS.new)
urgences_loc_sans_na$lon <- data.frame(coordinates(urgences_loc_sans_na))$X
urgences_loc_sans_na$lat <- data.frame(coordinates(urgences_loc_sans_na))$Y


factpal <- colorFactor(topo.colors(3), urgences_loc_sans_na$ID_A4) # palette de 3 couleurs

m <- leaflet(urgences_loc_sans_na) %>% addTiles() %>%
                  addCircles(lng = ~lon, lat = ~lat, weight = 1,
                             radius = ~ID_A103*100, 
                             popup = ~paste(rs, ", nb de passages : ", ID_A103, ", type de structure :", ID_A4),
                             color = ~factpal(ID_A4), fillOpacity = 0.5) %>%
                  addLegend("bottomleft", title = "Type de structure d'urgences", pal = factpal, values = ~ID_A4, opacity = 0.7)
htmlwidgets::saveWidget(as.widget(m), file = "carto.html")
```

Cartographie avec Leaflet - résultat
========================================================

<iframe src="carto.html" style="position:absolute;height:100%;width:100%"></iframe>


